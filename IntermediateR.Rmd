---
title: "Intermediate R"
author: "Allison Theobold"
output: pdf_document
---

# Relational Operators  

Relational operators tell how one object relates to another. There are a variety of relational operators that you have used before in mathematics, but take on a slightly different feel in computer science. We will walk through a few examples of different relational operators and the rest will be left as exercises.   

* __Equality & Inequality__: This type of operator tells whether an object is equivalent to another object, or its negation.  

```{r equality}  
# write R code to see if 
    # TRUE equals FALSE.
    # if -6 * 14 is not equal to 17 - 101  
    # if the strings "useR" and "user" are equal 
    # are TRUE and 1 equal?

```

* __Greater & Less__: These statements should be familiar, with a bit of a notation twist. To write a greater than or equal to statement you would you ``= >`` in your statement, and similarly with less than or equal to.  

```{r greaterLess}
# write R code to see if
    # -6 * 5 + 2 is greater than or equal to -10 + 1
    # "raining" is less than or equal to "raining dogs"  
    # TRUE is greater than FALSE
```

* __Matrices__: For matrices the above relational statements can be applied across the entire matrix, or to a subset of the matrix (a vector). The relational statement are applied element wise (a step-wise progression through the entries) 

```{r matricies}
# These dating data, of messages received per week, have been created for you

okcupid <- c(16, 9, 13, 5, 2, 17, 14)
match <- c(17, 7, 5, 16, 8, 13, 14)
messages <- matrix(c(okcupid, match), nrow = 2, byrow = TRUE)

# Use the messages matrix to return a logical matrix that answers the following questions:

  # When were the messages equal to 13?
  # For which days were the number of messages less than or equal to 14? 
```

# Logicals  

These statements allow for us to change or combine the results of the relational statements we discussed before, using "and", "or", or "not". 

* __"and"__ statements evaluate to ``TRUE`` \underline{only if every} relational statement evaluates to ``TRUE``. For example, ``(3 < 5) & (9 > 7)`` would evaluate to ``TRUE`` because \underline{both} relational statements are ``TRUE``. If instead we had ``(3 > 5) & (9 > 7)``, this would evaluate to ``FALSE`` as the first relational statement is ``FALSE``. 

* __"or"__ statements evaluate to ``TRUE`` \underline{if at least one} relational statement evaluates to ``TRUE``. For example, ``(3 > 5) | (9 > 7)`` would evaluate to ``TRUE`` because \underline{one} of the relational statements is ``TRUE`` (the second one). If instead we had ``(3 > 5) & (9 < 7)``, this would evaluate to ``FALSE`` as both relational statements evaluate to ``FALSE``.  

* __Remark:__ The ``&&`` and ``||`` logical statements \underline{do not} evaluate the same as their single counterparts. Instead, these logical operators evaluate to ``TRUE`` or ``FALSE`` based \underline{only} on the first element of the statement, vector, or matrix.  

```{r logicals}
# Using the messages data from above, answer the following questions. 

    # Is last under 5 or above 10? 
    # Is last between 15 and 20, excluding 15 but including 20?
```

## Logicals in Your Daily (Statistics) Life  

Many of you may be wondering how the topics above relate to your daily lives in statistical practices, but wait! Let's play with some data some functions that are likely very familiar to you. Import the BlackfootFish dataset and carry out the following questions:  

*  Which fish do no have \underline{both} length and weight recorded? (hint: use relational operators, logicals, and the ``which`` or ``subset`` functions)  

* Remove the fish you found from the dataset, renaming the new dataset ``BlackfootFish2``. 

* Subset these data so that only the Rainbow Trout (RBT) and Brown Trout (Brown) remain. 

```{r logicalPractice}

```

# Conditional Statements  

Conditional statements utilize relational statements and logicals to change the results of your ``R`` code. You may have encountered an ``ifelse`` statement before (or not), but let's breakdown exactly what ``R`` is doing when it evaluates them.  

## If Statements  

First, let's start with an ``if`` statement, the often overlooked building block of the ``ifelse`` statement. The ``if`` statement is structured as follows:  

\begin{center}
\begin{verbatim}
if(condition){
              statement
}
\end{verbatim}
\end{center}

* the condition inside the parenthesis is what the computer executes to verify that it is ``TRUE``,  
* if the condition evaluates to ``TRUE`` then the statement inside the ``{}`` is output, and  
* if the condition is ``FALSE`` nothing is output.

## Else Statements  

Since whenever an ``if`` statement evaluates to ``FALSE`` nothing is output, you might see why an ``else`` statement might be beneficial! An else statement allows for another statement to be output whenever the ``if`` condition evaluates to ``FALSE``. The ``ifelse`` statement is structured as follows:  

\begin{center}
\begin{verbatim}
if(condition){
              statement1
}
else{
              statement2      
}
\end{verbatim}
\end{center}

* again, the ``if`` condition is executed first,  
    + if it evaluates to ``TRUE`` then the first statement (``{statement1}``) is output,
    + if the condition is ``FALSE`` the computer moves on to the ``else`` statement, and  
* the second statement (``{statement2}``) is output. 

## Else If Statements  

On occasion, you may want to add a third (or forth, or fifth, ...) condition to your ``ifelse`` statement, which is where the ``elseif`` statement comes it. The ``elseif`` statement is added to the ``ifelse`` as follows:  

\begin{center}
\begin{verbatim}
if(condition1){
              statement1
}
elseif(condition2){
              statement2
}
else{
              statement3      
}
\end{verbatim}
\end{center}

* The ``if`` condition is executed first,  
    + if it evaluates to ``TRUE`` then the first statement (``{statement1}``) is output,
    + if the condition is ``FALSE`` the computer moves on to the ``elseif`` condition,  
* Now the second condition is executed, 
    + if it evaluates to ``TRUE`` then the second statement (``{statement2}``) is output,
    + if the condition is ``FALSE`` the computer moves on to the ``else`` statement, and 
* the third statement (``{statement3}``) is output. 

\vspace{0.25cm}

```{r if, tidy = TRUE}
# Using the message dataset, write an if statement that prints "You're popular!" if the number of messages exceeds 10
```

```{r else, tidy = TRUE}
# Using the if statements above add the following:  
    # When the if-condition on messages is not met, R prints out "Send more messages!" 
```

```{r elseif, tidy = TRUE}
# Using the ifelse statement above add the following:  
    # "Your number of views is average" is printed if messages is between 15 (inclusive) and 10 (exclusive). 
```

\pagebreak

# Combine It All!  

```{r combine1, eval = FALSE}

# Variables related to your last day of recordings
ma <- tail(match, 1)
ok <- tail(okcupid, 1)

# Code the control-flow construct
if (___ & ___) {
  sms <- 2 * (li + fb)
} elseif (___) {
  sms <- 0.5 * (li + fb)
} else {
  sms <- ___
}

# 1. If both ma and ok are 15 or higher, set sms equal to double the sum of ma and ok.
# 2. If both ma and ok are strictly below 10, set sms equal to half the sum of ma and ok.
# 3. In all other cases, set sms equal to ma + ok.
# 4. Print the resulting sms variable to the console.
```

\pagebreak 

# Loops  

Loops are a popular way to iterate or replicate a set of instructions. It is no more than creating an automated process by organizing a sequence of steps and grouping the steps that need to be repeated. In general, the advice of many ``R`` users would be to learn about loops, but once you have a clear understanding of them to get rid of them. Loops will give you a detailed view of what is happening and the data you are manipulating. Once you have this understanding, you should put your effort into learning about vectorized alternatives as they pay off in efficiency. These loop alternatives (the apply family) will be covered in the _Simulation Workshop_.  

Typically in computer science, we separate loops into two types. The loops that execute a process a specified number of times, where the "index" or "counter" is incremented after each cycle are part of the ``for`` loop family. On the other hand, other loops only repeat themselves until a conditional statement is evaluated to be ``FALSE``. These conditional loops belong to the ``while`` family.

![Loop Flowchart ](loop_flowchart.png)

## For Loops  

In the for loop figure above:   

* The rectangular `init` box represents the initialization of the object being used in the for loop (i.e. the variable). This initialization is \underline{required} in ``R``, as opposed to other languages, such as Python, where an initialization does not have to occur.  

* The diamond shapes represent the repeat decision the computer is required to make. The computer evaluates the conditional statement ($v \in seq$) as either ``TRUE`` or ``FALSE``. In other terms, you are testing if in the current value of $v$ is within the specified range of values $seq,$ where this range is defined in the initialization (like 1:100).  

* The second `i1` rectangle represents the set of instructions to execute for every iteration. This could be a simple statement, a block of instructions, or another loop (nested loops).  

The computer marches through this process until the the conditional statement evaluates to ``FALSE`` ($v \notin seq$).  

### Notation  

The for loop is placed between curly braces, which can be placed either directly after the test condition or beneath it. You will find the formatting that you like best for things such as loops and functions, but here is my preferred syntax.  

\begin{center}
\begin{verbatim}
for(i in 1:n){
              statement
}
\end{verbatim}
\end{center}

\vspace{0.25cm}

```{r forloop}
# Create a vector filled with random t-values, from a distribution with 32 degrees of freedom 

sim <- 100
u <- rt(sim, 32)
print("This loop calculates the square of the elements of vector u")

# Initialize `usq` (could have used a 0 initialization)
usq <- NA

for(i in 1:sim) {
  # i-th element of `u1` squared into `i`-th position of `usq`
  usq[i] <- u[i]^2
}

print(i) ## should be the same as sim, unless the loop had issues!
```

### Nesting For Loops  

Now that you know that for loops can also be nested, you're probably wondering when and why you would be using this in your code.  

```{r nestedloops}
# Create a matrix probabilities of drawing binomials 0-5, from a population of 5, a sample size of 2, and probabilities going from 0-1 by 0.1
x <- 0:5
theta <- seq(0, 1, by = 0.1)

probs <- matrix(NA, nrow = length(x), ncol = length(seq(0, 1, by = 0.1)))

# For each row and for each column, assign values based on position: product of two indexes
for(i in 1:length(x)){
  for(j in 1:length(theta)){
    probs[i,j] = dbinom(x[i], 5, theta[j])
  }
}
probs
```
## While Loops  

